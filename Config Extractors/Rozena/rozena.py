# Tested on
# 0254ed6c06048d7094531ed34a066e0a03ab67d5cc4beace0dc5efa8a9a1d982
# 034cf2b723753fd401b50906f222ce4933a811fe2625cb1d291f35e80dc7131c
# 072b699a7863d018f0366b300c96bea4cbd9a4f13a99e8ca99321014e2911160
# 094f051060f77d4ce45b00397dbc9c21632d43b59f4f7e7b161fb41a6d6ebcb6
# 0a35d2dc8c47c245ff096993387e16a2f43fc83a33f26db47e2fe952ad38ce45
# 0b5132488018b6644dc10ab00525c714aa03b13bc48a615e4981ba4811263c23
# 1662df2a6a4801b705994cba1d6ea31e29807c551fb28555e355c70a65f3271a
# 1cec5408893be1b8942c9164c41df9dea46494aa06a998ab1892354a112d6e00
# 28eef580a9fa7e0b98491022d6f07c4ef59971ace90b994b4fbf52fa173d04f3
# 3358536b67259eecd39ea7c7e17b2c7b83731ab87f89171837e863e2a2ecce53
# 40919a5260caa74b183953fb8dc34e59e23d9e6dc7b1878dff67caf3b0f93230
# 73e4c3bcc060ca9bc5cb9a13201029a03ae5fd131b84261a9ad8fbc59e22dac5
# 7ec18aef23ca2381313a2d4c9bd46729c5d6ae81c580bd442483ac7a2d2c8257
# a74a71ef2cef0dc90b066986cc022094154c1fe09e0bbdbcaefb0e30082207ee
# aeb05df0b865df62cebceab0e5259d69d39a1c8d4f623a2491dc302ac56ee9f0
# b01651bfef7908d1f51b301aae0104711307be6c05b8384cb1167f2daeff520d
# b04231bab6484665dda078815ad1affb339959ffec4f14f8a7ddd6b5b6df5a1e
# bb12c5ce83970ae19ff59f146882e16f2911cd4fd43053d934e78d19c5327291
# c32ddf1ce6946115e2c3515299997d7263601a9c3ea0313eadf9f82c4c59d8f0
# da0acd72e3a321797a8d9c1a77b0aedcb8b8e0d675d889eec2911b5550051f4c
# ee5af9b216c28c18011f644f4bffbd1bfb045f69b36b9fa1215b56831294d4f9
# f21ef6547b4c6099c7cf8c0efd569ed527d7919a7e7446753a49c623f38e27c3

import yara
import re
import sys

try:
    from unicorn import *
    from unicorn.x86_const import *
except ImportError:
    print("pip install unicorn")

rule = """
    rule Hunting_Rule_ShikataGaNai_Modified {
        meta:
            author    = "Steven Miller"
            company   = "FireEye"
            reference = "https://www.fireeye.com/blog/threat-research/2019/10/shikata-ga-nai-encoder-still-going-strong.html"
            id = "fe266a42-0480-5a98-9368-8a18aa5e4f69"
            modified_by = "Mohannad Raafat"

        strings:
            // CASE-1: If the shellcode starts with moving the XOR Key
            $varInitializeAndXorCondition1_XorEAX = { B8 ?? ?? ?? ?? [0-30] D9 74 24 F4 [0-10] ( 59 | 5A | 5B | 5C | 5D | 5E | 5F ) [0-50] 31 ( 40 | 41 | 42 | 43 | 45 | 46 | 47 ) ?? }
            $varInitializeAndXorCondition1_XorEBP = { BD ?? ?? ?? ?? [0-30] D9 74 24 F4 [0-10] ( 58 | 59 | 5A | 5B | 5C | 5E | 5F ) [0-50] 31 ( 68 | 69 | 6A | 6B | 6D | 6E | 6F ) ?? }
            $varInitializeAndXorCondition1_XorEBX = { BB ?? ?? ?? ?? [0-30] D9 74 24 F4 [0-10] ( 58 | 59 | 5A | 5C | 5D | 5E | 5F ) [0-50] 31 ( 58 | 59 | 5A | 5B | 5D | 5E | 5F ) ?? }
            $varInitializeAndXorCondition1_XorECX = { B9 ?? ?? ?? ?? [0-30] D9 74 24 F4 [0-10] ( 58 | 5A | 5B | 5C | 5D | 5E | 5F ) [0-50] 31 ( 48 | 49 | 4A | 4B | 4D | 4E | 4F ) ?? }
            $varInitializeAndXorCondition1_XorEDI = { BF ?? ?? ?? ?? [0-30] D9 74 24 F4 [0-10] ( 58 | 59 | 5A | 5B | 5C | 5D | 5E ) [0-50] 31 ( 78 | 79 | 7A | 7B | 7D | 7E | 7F ) ?? }
            $varInitializeAndXorCondition1_XorEDX = { BA ?? ?? ?? ?? [0-30] D9 74 24 F4 [0-10] ( 58 | 59 | 5B | 5C | 5D | 5E | 5F ) [0-50] 31 ( 50 | 51 | 52 | 53 | 55 | 56 | 57 ) ?? }

            // CASE-2: If the shellcode starts with 'fcmovu' instruction and 'fnstenv'
            $varInitializeAndXorCondition2_XorEAX = { (DA | DB | DC | DD) ?? D9 74 24 F4 [0-30] B8 ?? ?? ?? ?? [0-10] ( 59 | 5A | 5B | 5C | 5D | 5E | 5F ) [0-50] 31 ( 40 | 41 | 42 | 43 | 45 | 46 | 47 ) ?? }
            $varInitializeAndXorCondition2_XorEBP = { (DA | DB | DC | DD) ?? D9 74 24 F4 [0-30] BD ?? ?? ?? ?? [0-10] ( 58 | 59 | 5A | 5B | 5C | 5E | 5F ) [0-50] 31 ( 68 | 69 | 6A | 6B | 6D | 6E | 6F ) ?? }
            $varInitializeAndXorCondition2_XorEBX = { (DA | DB | DC | DD) ?? D9 74 24 F4 [0-30] BB ?? ?? ?? ?? [0-10] ( 58 | 59 | 5A | 5C | 5D | 5E | 5F ) [0-50] 31 ( 58 | 59 | 5A | 5B | 5D | 5E | 5F ) ?? }
            $varInitializeAndXorCondition2_XorECX = { (DA | DB | DC | DD) ?? D9 74 24 F4 [0-30] B9 ?? ?? ?? ?? [0-10] ( 58 | 5A | 5B | 5C | 5D | 5E | 5F ) [0-50] 31 ( 48 | 49 | 4A | 4B | 4D | 4E | 4F ) ?? }
            $varInitializeAndXorCondition2_XorEDI = { (DA | DB | DC | DD) ?? D9 74 24 F4 [0-30] BF ?? ?? ?? ?? [0-10] ( 58 | 59 | 5A | 5B | 5C | 5D | 5E ) [0-50] 31 ( 78 | 79 | 7A | 7B | 7D | 7E | 7F ) ?? }
            $varInitializeAndXorCondition2_XorEDX = { (DA | DB | DC | DD) ?? D9 74 24 F4 [0-30] BA ?? ?? ?? ?? [0-10] ( 58 | 59 | 5B | 5C | 5D | 5E | 5F ) [0-50] 31 ( 50 | 51 | 52 | 53 | 55 | 56 | 57 ) ?? }

            // CASE-3: If the shellcode starts with 'fcmovu' instruction and moving the XOR Key
            $varInitializeAndXorCondition3_XorEAX = { (DA | DB | DC | DD) ?? B8 ?? ?? ?? ?? [0-30] D9 74 24 F4 [0-10] ( 59 | 5A | 5B | 5C | 5D | 5E | 5F ) [0-50] 31 ( 40 | 41 | 42 | 43 | 45 | 46 | 47 ) ?? }
            $varInitializeAndXorCondition3_XorEBP = { (DA | DB | DC | DD) ?? BD ?? ?? ?? ?? [0-30] D9 74 24 F4 [0-10] ( 58 | 59 | 5A | 5B | 5C | 5E | 5F ) [0-50] 31 ( 68 | 69 | 6A | 6B | 6D | 6E | 6F ) ?? }
            $varInitializeAndXorCondition3_XorEBX = { (DA | DB | DC | DD) ?? BB ?? ?? ?? ?? [0-30] D9 74 24 F4 [0-10] ( 58 | 59 | 5A | 5C | 5D | 5E | 5F ) [0-50] 31 ( 58 | 59 | 5A | 5B | 5D | 5E | 5F ) ?? }
            $varInitializeAndXorCondition3_XorECX = { (DA | DB | DC | DD) ?? B9 ?? ?? ?? ?? [0-30] D9 74 24 F4 [0-10] ( 58 | 5A | 5B | 5C | 5D | 5E | 5F ) [0-50] 31 ( 48 | 49 | 4A | 4B | 4D | 4E | 4F ) ?? }
            $varInitializeAndXorCondition3_XorEDI = { (DA | DB | DC | DD) ?? BF ?? ?? ?? ?? [0-30] D9 74 24 F4 [0-10] ( 58 | 59 | 5A | 5B | 5C | 5D | 5E ) [0-50] 31 ( 78 | 79 | 7A | 7B | 7D | 7E | 7F ) ?? }
            $varInitializeAndXorCondition3_XorEDX = { (DA | DB | DC | DD) ?? BA ?? ?? ?? ?? [0-30] D9 74 24 F4 [0-10] ( 58 | 59 | 5B | 5C | 5D | 5E | 5F ) [0-50] 31 ( 50 | 51 | 52 | 53 | 55 | 56 | 57 ) ?? }
        condition:
            any of them
    }
    """


def hook_getShellCode(uc, address, size, mode):
    ins = uc.mem_read(address, size)

    # After the shellcode is decoded, there is a near relative 'call' instruction 
    # with fixed opcodes '\xE8\x8F\x00\x00\x00'
    if ins == (b"\xE8\x8F\x00\x00\x00"):
        print(f"[!] Reached to the end of decoding the shellcode at: {hex(address)}")
        uc.emu_stop()

    return True


def emulate(binaryEP: bytes, binarySize: int, hook=None):
    stackAddr = 0x00020000
    stackSize = 0x00010000
    codeAddr = 0x00040000
    codeSize = 0x1000

    uc = Uc(UC_ARCH_X86, UC_MODE_32)

    ## Stack Initialization
    uc.mem_map(stackAddr, stackSize)
    regESP = stackAddr + stackSize // 2
    uc.reg_write(UC_X86_REG_ESP, regESP)

    ## Code Initialization
    uc.mem_map(codeAddr, codeSize)
    uc.mem_write(codeAddr, binaryEP)

    if hook:
        uc.hook_add(UC_HOOK_CODE, hook, user_data=UC_MODE_32)

    uc.emu_start(codeAddr, codeAddr + binarySize)
    return uc


def extract_config(data: bytes):
    patternIP_PORT = re.compile(rb'\x68(....)\x68..(..)\x89', re.DOTALL)
    config_dict = {}

    yaraRules = yara.compile(source=rule)
    yaraHit = yaraRules.match(data=data)
    shellCodeSize = 0x400  ## Most of the Metasploit payloads' size between 0x150 and 0x390
    shellCodeStartOffset = 0

    if yaraHit:
        for item in yaraHit[0].strings:
            for instance in item.instances:

                ## Sometimes, there are more than one hits, so to reduce wrong offset, matched bytes size should be
                #  lower than or equal to 25 bytes
                if len(instance.matched_data) <= 25:
                    shellCodeStartOffset = instance.offset

        print(f"[!] Got the shellcode offset at: {hex(shellCodeStartOffset)}")
        shellCode = data[shellCodeStartOffset: shellCodeStartOffset + shellCodeSize]

        try:
            print(f"[!] Start emulating the shellcode")
            uc = emulate(shellCode, shellCodeSize, hook_getShellCode)
            unpackedSC = uc.mem_read(0x40000, shellCodeSize)

            matches = patternIP_PORT.findall(unpackedSC)
            if matches:
                ip = ''.join('.'.join(f'{c}' for c in matches[0][0]))
                port = int.from_bytes(matches[0][1], byteorder='big')

                config_dict["C2"] = ip
                config_dict["Port"] = port

            return config_dict

        except:
            print("[x] Failed to emulate the shellcode\n\n")
            return

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: rozena.py [sampleFile]")
        exit(1)
        
    with open(sys.argv[1], 'rb') as f:
        data = f.read()
        config = extract_config(data)
        print(config)