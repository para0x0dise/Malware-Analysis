# Tested on
# 01f5eafcf8d3e1c58db0d9a14427e3d9b95242a8229c5cb2550bc211e0785b9e
# 0ce8cad4973e7d3a6ea76bc56206941fb4d7bbebe4c0924b3fbb157b1938b537
# 11e622baa1481b2cc65c69b2cd93fa62e884dc33a680f907f6b079c735b790fe
# 14fc6472dea182171f0a5f4b7f88c25d933c5f2044b8ef3038dcd2da312b4aaf
# 1ec98dc02baa30cdf2c7b3d5971755329374ab7c982e2354445624f86333df48
# 1fca737283cfeed110061cb2f1508397ad0dcff1bf572bad9b31810361c8b4f5
# 2832174940c0dc1bf089b25411c553f93289d3683617b3a67f6f1e2de2ce4fc7
# 31109bdcb38a507a126953c3abbbbd0df9e621e4748f3ac33c332c3989f0997f
# 3134b8ccd158b31c28d489023ea9d62691d563f9b9dd107e8e64dda6088a6199
# 3d300877b0436eb6544d83071be8abdf953d3e1f748f6d6a7a376ff71e71898b
# 40e46407b549b2a594e3ac4e295d9eae1059fbc41c2603f1384146aa5983f26a
# 4141c747d73cfc8eb98ff222667ed0a0fe889436d84a33c822d6da52afb2a96b
# 57ea92d4bdea719c06cba145074b1a60e3689305c70fd8b4bcac88e0e94be932
# 5a20321f1adfc736beb53ccd8166fc48c1dc3052d2481012b3009cde430fadae
# 5d0bc5d770fe1f55489725c3d27f7f10b88f6e55c4832fb960bf01629bcbb7b4
# 66bfee81b238730c9a07347766e57f59b5b706dc9107025720f30edac654af1a
# 6ccdf2b9bb340096ec31eb9e12e0a651b20d5de5f642d91741dc754743ad07df
# 76152074372521b93fc050bf561281cc31b1af50b4923bb06d60577fefc5c9a5
# 8655899120c744232b6b01698a67afe4cf98307f92863c65b58b274bbee5433b
# 87461669a61ceba107d99b3fcce650f1c669bfaa46224e76641d48b932f9f0c4
# 8de925c3640585864cc563cceeb26c16893bb4e68e9ccd0fb69dffc0b4f3e689
# 93c8db705f405b9145677f69b4a396369c39a04cf87502ea94ac56e373267aac
# a6876f10a890dba219826fc9a340d26d7c5d63a2be6d96d2745abdc52753b99f
# af63227cb6a4fe78c3a4d1483f158cfe67e076a8ff2c3e9f7d801ca65536543c
# b04452cfb4d6c94c0459cd577156b03dae961965d5a560cd235add05001aa16c
# bbe4a92ed6e5160ea12f773002fb6862140c227be96196d6fe9c55c72ccb8123
# c2b995e4af6f53f5f2d7ebf28f3fdb6d45a56913cb57aa2f6c4e20addac400fb
# d03f9d61084c3a2bbdaa4e25f64a3fbb983797b84bae3323d31415543a9e21b5
# d36c53f7206f122420b2892b6f390c87979aa1e84839f2b07a12ddbea3c48c29
# d3edc0c9138863e8e19d5f2b0e237cf100582b4a3fd3030f0f2390f1f7e3af4b
# dcda17fb81239547dc552348c41f94a2eaccbc71da43d08d6c15f70d6b5157a4
# e1957d17110331b1b21e41383c9469e96cad0f9ce0e2097b878e18d6e77cd914
# e84da0f84bbcda5da566c85d64d618f90ad8dd4b742da88804b37015d11bcfe3
# e902865e90f56b9cb1f840db55af3bc74485ee5921ae436c7524c60bfe628330
# eaf7c50421f98264231df1480698ea5af945fbd5be5ac03544700b955c7b2c63

import re
import hashlib
import base64
import sys

try:
    import dnfile
    from Crypto.Cipher import AES

except ImportError:
    print("Please install the following packages: dnfile (ver. 0.14.1) and pycryptodome")
    exit(1)

config_dict = {}

confPattern = re.compile(
    rb"""(?x)
    \x72(...)\x70\x80...\x04
    """,
    re.DOTALL
)

mutexPattern1 = re.compile(
    rb"""(?x)
    \x72(...)\x70\x80...\x04
    \x72...\x70\x28...\x0A
    """,
    re.DOTALL
)

mutexPattern2 = re.compile(
    rb"""(?x)
    \x72(...)\x70\x80...\x04\x2A
    """,
    re.DOTALL
)

installBinNamePattern = re.compile(
    rb"""(?x)
    \x72(...)\x70\x80...\x04
    \x72...\x70\x80...\x04
    \x72...\x70\x28...\x0A
    """,
    re.DOTALL
)

installDirPattern = re.compile(
    rb"""(?x)
    \x72(...)\x70\x80...\x04
    \x72...\x70\x80...\x04
    \x72...\x70\x80...\x04
    \x72...\x70\x28...\x0A
    """,
    re.DOTALL
)

mutexPatterns = [mutexPattern1, mutexPattern2]
def deriveAESKey(encryptedMutex : str):
    md5Hash = hashlib.md5(encryptedMutex.encode()).hexdigest()
    AESKey = md5Hash[:30] + md5Hash + '00'
    return AESKey

def decryptAES(key : str, ciphertext : str, mode):
    cipher = AES.new(bytes.fromhex(key), mode)
    decodedcipher = base64.b64decode(ciphertext)
    decryptedBuff = cipher.decrypt(decodedcipher)

    valid_bytes = set(b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-/,')
    filtered_bytes = bytes(b for b in decryptedBuff if b in valid_bytes).decode('utf-8').split(',')
    if len(filtered_bytes) > 1:
        return filtered_bytes
    return ''.join(filtered_bytes)

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: xworm.py [sampleFile]")
        exit(1)

    with open(sys.argv[1], 'rb') as f:
        data = f.read()
        try:
            dn = dnfile.dnPE(data=data)
            extracted = []
            conf = []

            for pattern in mutexPatterns:
                mutexMatched = pattern.findall(data)
                if mutexMatched:
                    mutex = dn.net.user_strings.get_us(int.from_bytes(mutexMatched[0], "little")).value
                    AESKey = deriveAESKey(mutex)
                    break

            for match in confPattern.findall(data):
                er_string = dn.net.user_strings.get_us(int.from_bytes(match, "little")).value
                extracted.append(er_string)

            for i in range(5):
                conf.append(decryptAES(AESKey, extracted[i], AES.MODE_ECB))


            config_dict['C2'] = conf[0]
            if 1 <= int(conf[1]) <= 65535:
                config_dict['Port'] = conf[1]
                config_dict['AES Key (decrypt/encrypt connections)'] = conf[2]
                config_dict['SPL'] = conf[3]
            else:
                config_dict['Port'] = ''
                config_dict['AES Key (decrypt/encrypt connections)'] = conf[1]
                config_dict['SPL'] = conf[2]
            config_dict['AES Key (decrypt configs)'] = AESKey
            config_dict['Mutex'] = mutex

            installBinMatch = installBinNamePattern.findall(data)
            installDirMatch = installDirPattern.findall(data)

            if installDirMatch:
                installDir = dn.net.user_strings.get_us(int.from_bytes(installDirMatch[0], "little")).value
                config_dict['InstallDir'] = decryptAES(AESKey, installDir, AES.MODE_ECB)
            if installBinMatch:
                installBinName = dn.net.user_strings.get_us(int.from_bytes(installBinMatch[0], "little")).value
                config_dict['InstallBinName'] = decryptAES(AESKey, installBinName, AES.MODE_ECB)

            print(config_dict)

        except Exception as e:
            print(e)

