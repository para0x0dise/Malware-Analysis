import yara
import os
import psutil

def getAllPartitions():
    partitions = psutil.disk_partitions()
    hard_drives = []
    for partition in partitions:

        if 'cdrom' in partition.opts or partition.fstype == '':
            continue
        try:
            # To ensure that this is a valid partition
            usage = psutil.disk_usage(partition.mountpoint)
            hard_drives.append(partition.device)
        except PermissionError:
            continue
    return hard_drives


rule_source = """
rule neshtaWorm
{   strings:
		$neshtaHeader = {44 65 6C 70 68 69 2D 74 68 65 20 62 65 73 74 2E 20 46 75 63 6B 20 6F 66 66 20 61 6C 6C 20 74 
		68 65 20 72 65 73 74 2E 20 4E 65 73 68 74 61 20 31 2E 30 20 4D 61 64 65 20 69 6E 20 42 65 6C 61 72 75 73 2E}

	condition:
        uint16(0) == 0x5a4d and $neshtaHeader
}
"""

def getAllExecutables(drive: str):
    print("[+] Start collecting executables..")

    exePaths = []
    for root, dirs, files in os.walk(drive):
        for file in files:
            if file.endswith('.exe'):
                file_path = os.path.join(root, file)
                if not "System32" in file_path and not "SysWOW64" in file_path and not "Recycle" in file_path:
                    exePaths.append(file_path)

    return exePaths


def getXORByte(initialValue: int) -> list:
    """ Gets a list of next seed and xor byte which will be used to decrypt the PE header byte """

    seed = ((initialValue * 0x8088405) + 1) & 0xffffffff
    xorByte = (seed * 0xff) >> 32
    return [seed, xorByte]


def decryptPEHeader(encryptedBuff: bytes, initialVal: int) -> bytes:
    """ Decrypts the first 1000 bytes (encrypted PE Headers of the original exe), and then add the remaining buffer """

    decryptedPEHeader = bytearray()
    try:
        # Get initial seed and xor byte
        seed, xorByte = getXORByte(initialVal)

        decryptedPEHeader.append(encryptedBuff[0] ^ xorByte)

        for b in encryptedBuff[1:1000]:
            seed, xorByte = getXORByte(seed)
            decryptedPEHeader.append(b ^ xorByte)

        decryptedPEHeader.extend(encryptedBuff[1000:])
        return bytes(decryptedPEHeader)

    except Exception as e:
        print(f"[x] Error while decrypting PE Header.")
        raise e


def yara_scan(filePath: str, ruleSource: str) -> bool:
    try:
        yara_rules = yara.compile(source=ruleSource)
        matches = yara_rules.match(filePath)
        if matches:
            return True
    except Exception as e:
        print(f"[x] Error while scanning {filePath} with yara.")
        print(f"{e}")

def removeNesthaArtifacts():
    try:
        artifactPath = os.path.join(os.environ.get('SystemRoot'), 'svchost.com')
        if artifactPath:
            os.remove()
            print("[+] svchost.com has been removed.")
    except Exception as e:
        print(f"[x] Error while removing Neshta artifacts.")
        print(f"{e}")
def restoreOriginalFile(path: str, originalFileBytes: bytes):
    try:
        os.remove(path)
        with open(path, 'wb') as f:
            f.write(originalFileBytes)
    except Exception as e:
        print(f"[x] Error while writing new file {path}.")
        print(f"{e}")

if __name__ == '__main__':
    counter = 0
    paths = []
    for partition in getAllPartitions():
        paths = getAllExecutables(partition)

    print("[+] Start decrypting executables..")

    for path in paths:
        if yara_scan(path, rule_source):
            f = open(path, 'rb')
            fileContents = f.read()
            f.close()

            fileSize = os.path.getsize(path)
            print(f"[+] {path.split('//')[-1]} size: {fileSize} bytes.")

            wormContents = fileContents[:0xA200]
            encryptedPEHeader = fileContents[fileSize - 0xA200:]
            seedInitialValue = int.from_bytes(encryptedPEHeader[0x4d2:0x4d2 + 4], byteorder='little')

            print(f"[+] Seed initial Value: {hex(seedInitialValue)}.")
            print(f"[+] Start decrypting: {path}")

            decryptedPEPortion = decryptPEHeader(encryptedPEHeader, seedInitialValue)
            originalEXE = decryptedPEPortion + fileContents[0xa200:fileSize - 0xA200]
            restoreOriginalFile(path, originalEXE)
            counter += 1

    input(f"\n[+] Restored {counter} files.")